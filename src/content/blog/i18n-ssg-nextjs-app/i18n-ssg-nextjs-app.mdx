---
published: "false"
title: "i18n with Next.js and full SSG support"
author: "BiscuiTech"
date: "2020-05-06"
excerpt_en: "Having a React app with localization in multiple languages is really, really hard. But is there a better way?"
excerpt_fr: "Avoir une app React localisé en plusieurs langues est très, très difficile. Mais est-ce qu'il y aurait une meilleure façon?"
coverImage: "https://images.unsplash.com/photo-1508633069371-a735f885a1c7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=600&q=80"
imageAccreditation: "Matthew Brodeur"
---

## The Issue

If you tried to look around for _simple_ i18n integrations of `next.js`, you'd soon realized that it just doesn't exist. The reference in the next.js example directory managed by Vercel (formely known as Zeit) points to an integration using a _custom server_. Although it's a nice display of next's different capabilities, we want to statically generate the html on the server - Server Side Generation. Using a custom server makes all serverless and static optimizations impossible.

So let's dive in using Next.js 9.3 Server-Side Generation (SSG) and 100% serverless.

## The Setup

First, create a folder to work with, then initialize your app with next's create app.

```shell
npm init next-app --example with-typescript with-typescript-app
```

We're using TypeScript in this example because it's a nicer approach when working with the `Locale` type. More on that soon.

`cd` in the newly created folder and run `npm run dev`. You should have an app looking like this:

![](/content/blog/images/2020-05-04-17-25-39-image.png)

Now that we have a barebones app up and running, let's dig into the meat of the subject.

## The Types

Create a folder in /src called translations. In it, create a types.ts file.

```typescript
// ../src/translations/types.ts
import { locales } from "./config";

export type Locale = typeof locales[number];

export interface Translations {
  [key: string]: string;
}

export type Strings = {
  [key in Locale]: Translations;
};

export type Localization = {
  locale: Locale;
  translations: Translations;
  namespace: string;
};

export function isLocale(tested: string): tested is Locale {
  return locales.some((locale) => locale === tested);
}
```

Then, create a config.ts.

```typescript
// ../src/translations/config.ts
export const defaultLocale = "en" as const;

export const locales = ["en", "fr"] as const;

export const languageNames = {
  en: "English",
  fr: "Français",
};
```

Those files are self explanatory, but quickly it goes like this:

- config.ts serves as the constants used throughout the Context.

- The types will help us populate the Context and the localizations instances correctly.

## The Context

Next up, we need to create a react context. This will server as the focal point of all the text strings the app will load on each page.

Inside your /src folder, create a context folder and a LanguageContext.tsx file.

```typescript
// ../src/context/LanguageContext.tsx
export const LanguageContext = React.createContext<ContextProps>({
  localization: {
    locale: "en", // default lang
    translations: strings.common, // default translations
    namespace: "common", // default namespace
  },
  setLocale: () => null,
});
```

The context will hold an object called `localization` with the keys `locale`, `translations`and `namespace`.

- `locale` is the active language of the site. As a default, we're using 'en' for english.

- `translations` will hold all the text strings. As a default we're using the _common_ strings. Those will make sense later.

- `namespace` will serve as the key to dynamically fetch text strings. As a default, we're using `common`.

A context is nothing without a provider to ... well, provide it! Let's add it to our file.

```typescript
// ../src/context/LanguageContext.tsx
export const LanguageProvider: React.FC<{ localization: Localization }> = ({
  localization,
  children,
}) => {
  const [localizationState, setLocalizationState] = React.useState({
    locale: localization?.locale,
    translations: localization?.translations,
    namespace: localization?.namespace,
  });
  const [getStoredLocale, setStoredLocale] = useLocalStorage("locale");
  const { query } = useRouter();
  React.useEffect(() => {
    if (localizationState !== getStoredLocale) {
      setStoredLocale(localizationState);
    }
  }, [localizationState]);

  React.useEffect(() => {
    if (
      typeof query.lang === "string" &&
      isLocale(query.lang) &&
      localization?.locale !== query.lang
    ) {
      setLocalizationState({
        locale: localization?.locale,
        translations: localization?.translations,
        namespace: localization?.namespace,
      });
    }
  }, [query.lang, localizationState]);

  return (
    <LanguageContext.Provider
      value={{ localization, setLocale: setLocalizationState }}
    >
      {children}
    </LanguageContext.Provider>
  );
};
```

Alright, this is a big file. Let's break it down.

```typescript
export const LanguageProvider: React.FC<{ localization: Localiztion }> = ({
  localization,
  children,
}) => {
  return (
    <LanguageContext.Provider
      value={{ localization, setLocale: setLocalizationState }}
    >
      {children}
    </LanguageContext.Provider>
  );
};
```

This is the declaration and rendering portion. `React.FC` is the react's Type for Functional Component, to which we add `localization` as a type, previously created in our types.ts file. Next, let's add `useState`.

```typescript
export const LanguageProvider: React.FC<{ localization: Localiztion }> = ({
  localization,
  children,
}) =>{
  const [localizationState, setLocalizationState] = React.useState({
      locale: localization?.locale,
      translations: localization?.translations,
      namespace: localization?.namespace,
    });
  return (
    <LanguageContext.Provider
      value={{ localization,
      setLocale: setLocalizationState }}
    >
      {children}
    </LanguageContext.Provider>
  );
};
```
Here we add the state to the context. We will play with this state throughout the app!


```typescript
// ../src/context/LanguageContext.tsx
export const LanguageProvider: React.FC<{ localization: Localization }> = ({
  localization,
  children,
}) => {
  const [localizationState, setLocalizationState] = React.useState({
    locale: localization?.locale,
    translations: localization?.translations,
    namespace: localization?.namespace,
  });
  const [getStoredLocale, setStoredLocale] = useLocalStorage("locale");
  const { query } = useRouter();
  React.useEffect(() => {
    if (localizationState !== getStoredLocale) {
      setStoredLocale(localizationState);
    }
  }, [localizationState]);

  React.useEffect(() => {
    if (
      typeof query.lang === "string" &&
      isLocale(query.lang) &&
      localization?.locale !== query.lang
    ) {
      setLocalizationState({
        locale: localization?.locale,
        translations: localization?.translations,
        namespace: localization?.namespace,
      });
    }
  }, [query.lang, localizationState]);

  return (
    <LanguageContext.Provider
      value={{ localization, setLocale: setLocalizationState }}
    >
      {children}
    </LanguageContext.Provider>
  );
};
```

And finally, we set and get a LocalStorage key of "locale". This will mainly serve as a lower level mechanism to know which locale the user is in. By setting a LocaleStorage, we can also write it to memory for future visits by our users.

You'll also note there's two useEffects. The first one syncs our LocaleStorage from our state each time the state mutates. The second one writes to state the localized strings and mutates every time it changes. It also checks for errors by making sure the query from `router` is in fact a supported language. Note: if it's not a supported language, it'll simply revert to `en`.

## getStaticPaths & getStaticProps

So, now we have the Provider setup. How in the hell do we get localized strings?!

Well I'm glad you asked! We load it simply by calling a sort of API. And in Next.js, how do we call an API? On a per-page basis in `getStaticProps`!

```typescript
// ./src/pages/whatever-page-want.tsx
export const getStaticProps: GetStaticProps = async (ctx) => {
  const lang: Locale = ctx.params?.lang || "en";
  const locale: any = locales[lang];
  const strings: any = locale[namespace];
  const translations = {
    common: locales[lang].common,
    ...strings,
  };
  return {
    props: {
      localization: {
        locale: ctx.params?.lang,
        translations,
        namespace,
      },
    },
  };
};


export const getStaticPaths: GetStaticPaths = async () => {
  return {
    paths: ["en", "fr"].map((lang) => ({ params: { lang } })),
    fallback: false,
  };
};

```

Easy as 1,2,3! As a side note, you also need to tell next.js to build all the pages of your locales. You can do that in getStaticPaths. You can read more on getStaticPaths here: [nextjs.org/docs](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation)

This is all working thanks to dynamic imports in your locale files structure. It looks a bit like this:

```typescript
//../src/translations/locales/en/index.ts
import contact from './contact'
import common from './common'
import home from './home'
import blog from './blog'
import blogPost from './blogPost'
import about from './about'
import uses from './uses'

export default {
  contact,
  common,
  home,
  blog,
  about,
  blogPost,
  uses
}

// ../src/translations/locales/en/home.ts
const home = {
  firstString: 'Hi, my name is',
  i_am: 'I am a Web Developer from Montréal.',
  short_intro:
  "I make excellent website experiences basedon modern tools such as React and GraphQL.",
  latestBlog: "Latest Blog",
  viewBlog: "Read this article",
  readFullBlog: "Read full blog",
}

export default home
```

I highly suggest you inspect the repo of my website [here](https://github.com/BiscuiTech/BiscuiT). You'll get a better grip of how all the files work together.


Getting back to our pages/page.ts, we need to adjust one more thing. Add the Provider and pass the translations objet down.

```typescript
const IndexPage: NextPage<{
  localization: Localization;
  preview: boolean;
}> = ({ localization, posts, preview = false }) => {
  return (
    <LanguageProvider localization={localization}>
      <Layout>
        <Home />
      </Layout>
    </LanguageProvider>
  );
};
export default IndexPage
```
Simple, isn't it!

With this method, the only code actually changing your app (besides the translations portions itself) is the page file.

## useTranslate

Now that we have the props passed down and ready to grab, we simply need to use them inside our components.

```typescript
// ../src/components/SomeComponent.tsx
export const Home = ({ post }) => {
  const { locale, t } = useTranslation();
  return (
    <div>
      <h1 className="welcome--hello">
        {t("welcome_msg")}
        <br />
        <span className="welcome--my-name">Jean-Cédric Huet</span>
      </h1>
      <p className="welcome--from">{t("i_am")}</p>
    </div>
  );
};
```

We're going to create a hook that fetches the translations props and make them available to us. If you understand how Context works, this is a piece of cake.

```typescript
// ..src/hooks/useTranslation.ts
import { useContext } from "react";
import { LanguageContext } from "../context/LanguageContext";

export default function useTranslation() {
  const { localization } = useContext(LanguageContext);
  function t(key: string) {
    if (!localization.translations[key]) {
      console.warn(
        `Translation '${key}' for locale '${localization.locale}' not found.`
      );
    }
    return localization.translations[key] || "";
  }

  return {
    t,
    locale: localization.locale,
  };
}
```

And now we're finally done - for real!